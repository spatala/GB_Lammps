import numpy as np
import math
import GBpy.tools as GBt
from misorient_fz_432 import misorient_fz_432
import GBpy.quaternion as GBq
from symm_equi_reps_Oh import symm_equi_reps_Oh
from five_param_symm_props import five_param_symm_props
from pick_fz_bpl import pick_fz_bpl



def five_param_fz(r_go1togo2_go1, bpn_go1):
    """The function uses the set of boundary plane normal vectors generated by b_planes_list method,
    to generate unique boundary plane normal vectors in the fundamental zone of bicrystal point group symmetry.

    Parameters
    ----------
    r_go1togo2_go1: numpy array with  dimensions 3x3
    The misorientation matrix in orthogonal coordinates measured in the reference frame of crystal 1 (go1).
    bpn_go1: numpy array with dimension 3x1
    The boundary plane vector, whose components are expressed in the orthogonal reference frame of crystal 1 (go1).

    Returns
    -------
    gb_fz: python list containing misorient_fz, bp_fz_norms_go1, bp_fz_stereo, symm_grp_ax, bp_symm_grp

        misorient_fz: numpy array 3x3
        The symmetrically equivalent misorientation matrix that lies in the fundamental zone
        (in go1 frame).
        bp_fz_norms_go1:numpy array 1x3
        The unit lattice vector that is parallel to the boundary plane vector that falls in the fundamental
        zone of the sphere of boundary plane vectors (in go1 frame).
        bp_fz_stereo:
        symm_grp_ax: numpy array 3x3
        The principal axes of bicrystal symmetry group stored column wise (in go1 frame).
        bp_symm_grp: python string
        The bicrystal symmetry group of the grain boundary. Possible values include 'C_s', 'C_2h', 'D_3d',
        'D_2h', 'D_4h', 'D_6h', 'D_8h' and 'O_h'.

    Notes
    -------
    *

    See Also
    --------
    GBpy.tools
    GBpy.quaternion

    """


    # symm_gbs = symm_equi_reps_Oh(r_go1togo2_go1, bpn_go1)
    # gb_type_tmp =[]
    #
    # for item in symm_gbs:
    #    gb_type_tmp.append(item[2])
    # gb_type_tmp = np.array(gb_type_tmp)
    # fz_inds = np.where(gb_type_tmp == 'FZ')[0]
    #
    # symm_gbs = np.array(symm_gbs)
    # misorient_fz = symm_gbs[fz_inds[0]][0]
    # # for i in fz_inds:
    # #     misorient_fz.append(symm_gbs[i][0])
    # # misorient_fz = np.array(misorient_fz)
    # try:
    #     rng1 = np.shape(fz_inds)[0]
    # except:
    #     rng1 = 1
    # bp_equi_go1 = []
    # for i in range(rng1):
    #     bp_equi_go1.append(np.array(symm_gbs[fz_inds[i]][1].T[0]))
    #     t_mat1 = np.dot((symm_gbs[fz_inds[i]][0]),misorient_fz.T)
    #     t_ax_ang1 = GBt.vrrotmat2vec(t_mat1); t_ang1 = t_ax_ang1[3]
    #     tol1 = 1e-04
    #     if t_ang1 > tol1:
    #         raise ValueError('Multiple FZ Misorientations')
    # bp_equi_go1 = np.array(bp_equi_go1)
    # for j in range(rng1):
    #     bp_equi_go1.append(symm_gbs[fz_inds[j]])
    # bp_equi_go1 = np.array(bp_equi_go1)

    # t1_vecs = bp_equi_go1; t1_vecs_norm = np.sqrt(np.sum(np.square(t1_vecs), 1))
    # t1_vecs[:, 0] = np.true_divide(t1_vecs[:, 0], t1_vecs_norm)
    # t1_vecs[:, 1] = np.true_divide(t1_vecs[:, 1], t1_vecs_norm)
    # t1_vecs[:, 2] = np.true_divide(t1_vecs[:, 2], t1_vecs_norm)

    # t1_vecs = bp_equi_go1
    # new_col = np.linalg.norm(t1_vecs, axis=1)
    # t1_vecs_norm = np.array([new_col, ]*3).T
    # t1_vecs = np.true_divide(t1_vecs, t1_vecs_norm)
    # bp_equi_go1 = t1_vecs
    # bp_equi_go1 = GBt.unique_rows_tol(bp_equi_go1, 1e-08)
    misquat = GBq.mat2quat(r_go1togo2_go1)[:-1]
    fz_quat = misorient_fz_432(misquat)

    mis_quat_fz = GBq.mat2quat(r_go1togo2_go1); lat_pt_grp = 'O_h'
    x_g, y_g, z_g, bp_symm_grp = five_param_symm_props(mis_quat_fz, lat_pt_grp, 1e-04)

    symm_grp_ax = np.zeros((3, 3))
    symm_grp_ax[:, 0] = x_g; symm_grp_ax[:, 1] = y_g; symm_grp_ax[:, 2] = z_g
    bp_fz_norms_go1, bp_fz_stereo = pick_fz_bpl(bpn_go1, bp_symm_grp, symm_grp_ax, 1e-04)

    gb_fz = [r_go1togo2_go1, bp_fz_norms_go1, bp_fz_stereo, symm_grp_ax, bp_symm_grp]

    return gb_fz
# r = np.array([[0.8, 0.6, 0], [0.6, -0.8, 0], [0, 0, -1]])
# b = np.array([[0], [-3], [-1]])
# dum = five_param_fz(r, b)
# print dum

# r = np.array([[0.6666667, -0.3333333, 0.6666667], [0.6666667, 0.6666667, -0.3333333], [-0.3333333, 0.6666667, 0.6666667]])
# b = np.array([[3], [1], [0]])
# print five_param_fz(r, b)
